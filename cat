diff --git a/src-tauri/src/simulations/flow/settings.rs b/src-tauri/src/simulations/flow/settings.rs
index fd8617d..983cd7a 100644
--- a/src-tauri/src/simulations/flow/settings.rs
+++ b/src-tauri/src/simulations/flow/settings.rs
@@ -178,7 +178,6 @@ pub struct Settings {
     pub trail_deposition_rate: f32,
     pub trail_diffusion_rate: f32,
     pub trail_wash_out_rate: f32,
-    pub trail_map_filtering: TrailMapFiltering,
 }
 
 impl Default for Settings {
@@ -206,7 +205,6 @@ impl Default for Settings {
             trail_deposition_rate: 1.0, // Maximum trail deposition strength
             trail_diffusion_rate: 0.0,  // No trail diffusion by default
             trail_wash_out_rate: 0.0,
-            trail_map_filtering: TrailMapFiltering::Nearest,
         }
     }
 }
diff --git a/src-tauri/src/simulations/flow/simulation.rs b/src-tauri/src/simulations/flow/simulation.rs
index aa6a284..06f756a 100644
--- a/src-tauri/src/simulations/flow/simulation.rs
+++ b/src-tauri/src/simulations/flow/simulation.rs
@@ -140,6 +140,7 @@ pub struct FlowModel {
     pub lut_reversed: bool,
     pub show_particles: bool,
     pub display_mode: DisplayMode,
+    pub trail_map_filtering: super::settings::TrailMapFiltering,
 
     // Mouse interaction state
     pub cursor_active_mode: u32, // 0 = inactive, 1 = attract, 2 = repel
@@ -523,14 +524,8 @@ impl FlowModel {
             address_mode_u: wgpu::AddressMode::ClampToEdge,
             address_mode_v: wgpu::AddressMode::ClampToEdge,
             address_mode_w: wgpu::AddressMode::ClampToEdge,
-            mag_filter: match settings.trail_map_filtering {
-                super::settings::TrailMapFiltering::Nearest => wgpu::FilterMode::Nearest,
-                super::settings::TrailMapFiltering::Linear => wgpu::FilterMode::Linear,
-            },
-            min_filter: match settings.trail_map_filtering {
-                super::settings::TrailMapFiltering::Nearest => wgpu::FilterMode::Nearest,
-                super::settings::TrailMapFiltering::Linear => wgpu::FilterMode::Linear,
-            },
+            mag_filter: wgpu::FilterMode::Nearest, // Default to nearest, will be updated later
+            min_filter: wgpu::FilterMode::Nearest, // Default to nearest, will be updated later
             mipmap_filter: wgpu::FilterMode::Nearest,
             ..Default::default()
         });
@@ -540,11 +535,8 @@ impl FlowModel {
         let common_layouts = CommonBindGroupLayouts::new(device);
 
         // Create particle update pipeline using GPU utilities
-        let particle_update_shader = shader_manager.load_shader(
-            device,
-            "flow_particle_update",
-            PARTICLE_UPDATE_SHADER,
-        );
+        let particle_update_shader =
+            shader_manager.load_shader(device, "flow_particle_update", PARTICLE_UPDATE_SHADER);
 
         let compute_bind_group_layout =
             device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
@@ -1329,7 +1321,6 @@ impl FlowModel {
                     binding: 1,
                     resource: wgpu::BindingResource::Sampler(&display_sampler),
                 },
-
                 wgpu::BindGroupEntry {
                     binding: 2,
                     resource: average_color_uniform_buffer.as_entire_binding(),
@@ -1432,6 +1423,7 @@ impl FlowModel {
             lut_reversed: false,
             show_particles: true,
             display_mode: DisplayMode::Age,
+            trail_map_filtering: super::settings::TrailMapFiltering::Nearest,
             trail_render_pipeline,
             trail_display_render_pipeline,
             trail_render_bind_group,
@@ -1541,7 +1533,12 @@ impl FlowModel {
         );
     }
 
-    fn clear_trail_texture(&self, device: &Arc<Device>, queue: &Arc<Queue>, background_color: [f32; 4]) {
+    fn clear_trail_texture(
+        &self,
+        device: &Arc<Device>,
+        queue: &Arc<Queue>,
+        background_color: [f32; 4],
+    ) {
         let mut encoder = device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
             label: Some("Clear Trail Texture Encoder"),
         });
@@ -1588,8 +1585,6 @@ impl FlowModel {
         self.average_color_resources.unmap_staging_buffer();
     }
 
-
-
     fn apply_post_processing(
         &self,
         device: &Arc<Device>,
@@ -2568,61 +2563,62 @@ impl Simulation for FlowModel {
                     );
 
                     // Create the compute bind group layout for particle update
-                    let compute_bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
-                        label: Some("Compute Bind Group Layout"),
-                        entries: &[
-                            wgpu::BindGroupLayoutEntry {
-                                binding: 0,
-                                visibility: wgpu::ShaderStages::COMPUTE,
-                                ty: wgpu::BindingType::Buffer {
-                                    ty: wgpu::BufferBindingType::Storage { read_only: false },
-                                    has_dynamic_offset: false,
-                                    min_binding_size: None,
+                    let compute_bind_group_layout =
+                        device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
+                            label: Some("Compute Bind Group Layout"),
+                            entries: &[
+                                wgpu::BindGroupLayoutEntry {
+                                    binding: 0,
+                                    visibility: wgpu::ShaderStages::COMPUTE,
+                                    ty: wgpu::BindingType::Buffer {
+                                        ty: wgpu::BufferBindingType::Storage { read_only: false },
+                                        has_dynamic_offset: false,
+                                        min_binding_size: None,
+                                    },
+                                    count: None,
                                 },
-                                count: None,
-                            },
-                            wgpu::BindGroupLayoutEntry {
-                                binding: 1,
-                                visibility: wgpu::ShaderStages::COMPUTE,
-                                ty: wgpu::BindingType::Buffer {
-                                    ty: wgpu::BufferBindingType::Storage { read_only: true },
-                                    has_dynamic_offset: false,
-                                    min_binding_size: None,
+                                wgpu::BindGroupLayoutEntry {
+                                    binding: 1,
+                                    visibility: wgpu::ShaderStages::COMPUTE,
+                                    ty: wgpu::BindingType::Buffer {
+                                        ty: wgpu::BufferBindingType::Storage { read_only: true },
+                                        has_dynamic_offset: false,
+                                        min_binding_size: None,
+                                    },
+                                    count: None,
                                 },
-                                count: None,
-                            },
-                            wgpu::BindGroupLayoutEntry {
-                                binding: 2,
-                                visibility: wgpu::ShaderStages::COMPUTE,
-                                ty: wgpu::BindingType::Buffer {
-                                    ty: wgpu::BufferBindingType::Uniform,
-                                    has_dynamic_offset: false,
-                                    min_binding_size: None,
+                                wgpu::BindGroupLayoutEntry {
+                                    binding: 2,
+                                    visibility: wgpu::ShaderStages::COMPUTE,
+                                    ty: wgpu::BindingType::Buffer {
+                                        ty: wgpu::BufferBindingType::Uniform,
+                                        has_dynamic_offset: false,
+                                        min_binding_size: None,
+                                    },
+                                    count: None,
                                 },
-                                count: None,
-                            },
-                            wgpu::BindGroupLayoutEntry {
-                                binding: 3,
-                                visibility: wgpu::ShaderStages::COMPUTE,
-                                ty: wgpu::BindingType::StorageTexture {
-                                    access: wgpu::StorageTextureAccess::ReadWrite,
-                                    format: wgpu::TextureFormat::Rgba8Unorm,
-                                    view_dimension: wgpu::TextureViewDimension::D2,
+                                wgpu::BindGroupLayoutEntry {
+                                    binding: 3,
+                                    visibility: wgpu::ShaderStages::COMPUTE,
+                                    ty: wgpu::BindingType::StorageTexture {
+                                        access: wgpu::StorageTextureAccess::ReadWrite,
+                                        format: wgpu::TextureFormat::Rgba8Unorm,
+                                        view_dimension: wgpu::TextureViewDimension::D2,
+                                    },
+                                    count: None,
                                 },
-                                count: None,
-                            },
-                            wgpu::BindGroupLayoutEntry {
-                                binding: 4,
-                                visibility: wgpu::ShaderStages::COMPUTE,
-                                ty: wgpu::BindingType::Buffer {
-                                    ty: wgpu::BufferBindingType::Storage { read_only: true },
-                                    has_dynamic_offset: false,
-                                    min_binding_size: None,
+                                wgpu::BindGroupLayoutEntry {
+                                    binding: 4,
+                                    visibility: wgpu::ShaderStages::COMPUTE,
+                                    ty: wgpu::BindingType::Buffer {
+                                        ty: wgpu::BufferBindingType::Storage { read_only: true },
+                                        has_dynamic_offset: false,
+                                        min_binding_size: None,
+                                    },
+                                    count: None,
                                 },
-                                count: None,
-                            },
-                        ],
-                    });
+                            ],
+                        });
 
                     self.particle_update_pipeline = ComputePipelineBuilder::new(device.clone())
                         .with_shader(particle_update_shader)
@@ -2670,61 +2666,62 @@ impl Simulation for FlowModel {
                     );
 
                     // Create the compute bind group layout for particle update
-                    let compute_bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
-                        label: Some("Compute Bind Group Layout"),
-                        entries: &[
-                            wgpu::BindGroupLayoutEntry {
-                                binding: 0,
-                                visibility: wgpu::ShaderStages::COMPUTE,
-                                ty: wgpu::BindingType::Buffer {
-                                    ty: wgpu::BufferBindingType::Storage { read_only: false },
-                                    has_dynamic_offset: false,
-                                    min_binding_size: None,
+                    let compute_bind_group_layout =
+                        device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
+                            label: Some("Compute Bind Group Layout"),
+                            entries: &[
+                                wgpu::BindGroupLayoutEntry {
+                                    binding: 0,
+                                    visibility: wgpu::ShaderStages::COMPUTE,
+                                    ty: wgpu::BindingType::Buffer {
+                                        ty: wgpu::BufferBindingType::Storage { read_only: false },
+                                        has_dynamic_offset: false,
+                                        min_binding_size: None,
+                                    },
+                                    count: None,
                                 },
-                                count: None,
-                            },
-                            wgpu::BindGroupLayoutEntry {
-                                binding: 1,
-                                visibility: wgpu::ShaderStages::COMPUTE,
-                                ty: wgpu::BindingType::Buffer {
-                                    ty: wgpu::BufferBindingType::Storage { read_only: true },
-                                    has_dynamic_offset: false,
-                                    min_binding_size: None,
+                                wgpu::BindGroupLayoutEntry {
+                                    binding: 1,
+                                    visibility: wgpu::ShaderStages::COMPUTE,
+                                    ty: wgpu::BindingType::Buffer {
+                                        ty: wgpu::BufferBindingType::Storage { read_only: true },
+                                        has_dynamic_offset: false,
+                                        min_binding_size: None,
+                                    },
+                                    count: None,
                                 },
-                                count: None,
-                            },
-                            wgpu::BindGroupLayoutEntry {
-                                binding: 2,
-                                visibility: wgpu::ShaderStages::COMPUTE,
-                                ty: wgpu::BindingType::Buffer {
-                                    ty: wgpu::BufferBindingType::Uniform,
-                                    has_dynamic_offset: false,
-                                    min_binding_size: None,
+                                wgpu::BindGroupLayoutEntry {
+                                    binding: 2,
+                                    visibility: wgpu::ShaderStages::COMPUTE,
+                                    ty: wgpu::BindingType::Buffer {
+                                        ty: wgpu::BufferBindingType::Uniform,
+                                        has_dynamic_offset: false,
+                                        min_binding_size: None,
+                                    },
+                                    count: None,
                                 },
-                                count: None,
-                            },
-                            wgpu::BindGroupLayoutEntry {
-                                binding: 3,
-                                visibility: wgpu::ShaderStages::COMPUTE,
-                                ty: wgpu::BindingType::StorageTexture {
-                                    access: wgpu::StorageTextureAccess::ReadWrite,
-                                    format: wgpu::TextureFormat::Rgba8Unorm,
-                                    view_dimension: wgpu::TextureViewDimension::D2,
+                                wgpu::BindGroupLayoutEntry {
+                                    binding: 3,
+                                    visibility: wgpu::ShaderStages::COMPUTE,
+                                    ty: wgpu::BindingType::StorageTexture {
+                                        access: wgpu::StorageTextureAccess::ReadWrite,
+                                        format: wgpu::TextureFormat::Rgba8Unorm,
+                                        view_dimension: wgpu::TextureViewDimension::D2,
+                                    },
+                                    count: None,
                                 },
-                                count: None,
-                            },
-                            wgpu::BindGroupLayoutEntry {
-                                binding: 4,
-                                visibility: wgpu::ShaderStages::COMPUTE,
-                                ty: wgpu::BindingType::Buffer {
-                                    ty: wgpu::BufferBindingType::Storage { read_only: true },
-                                    has_dynamic_offset: false,
-                                    min_binding_size: None,
+                                wgpu::BindGroupLayoutEntry {
+                                    binding: 4,
+                                    visibility: wgpu::ShaderStages::COMPUTE,
+                                    ty: wgpu::BindingType::Buffer {
+                                        ty: wgpu::BufferBindingType::Storage { read_only: true },
+                                        has_dynamic_offset: false,
+                                        min_binding_size: None,
+                                    },
+                                    count: None,
                                 },
-                                count: None,
-                            },
-                        ],
-                    });
+                            ],
+                        });
 
                     self.particle_update_pipeline = ComputePipelineBuilder::new(device.clone())
                         .with_shader(particle_update_shader)
@@ -2803,7 +2800,7 @@ impl Simulation for FlowModel {
             }
             "trailMapFiltering" => {
                 if let Some(filtering_str) = value.as_str() {
-                    self.settings.trail_map_filtering = match filtering_str {
+                    self.trail_map_filtering = match filtering_str {
                         "Nearest" => super::settings::TrailMapFiltering::Nearest,
                         "Linear" => super::settings::TrailMapFiltering::Linear,
                         _ => super::settings::TrailMapFiltering::Nearest,
@@ -2836,6 +2833,7 @@ impl Simulation for FlowModel {
             "lutReversed": self.lut_reversed,
             "showParticles": self.show_particles,
             "displayMode": self.display_mode,
+            "trailMapFiltering": self.trail_map_filtering,
         })
     }
 
@@ -2939,7 +2937,6 @@ impl Simulation for FlowModel {
                 0,
                 bytemuck::cast_slice(&[sim_params]),
             );
-
         }
 
         // Store cursor values in the model
@@ -3008,7 +3005,7 @@ impl Simulation for FlowModel {
     ) -> crate::error::SimulationResult<()> {
         if let Ok(new_settings) = serde_json::from_value::<Settings>(settings) {
             self.settings = new_settings;
-            
+
             // Update GPU buffers after applying new settings
             self.update_background_color(queue);
             self.write_sim_params(queue);
@@ -3033,7 +3030,7 @@ impl Simulation for FlowModel {
                 let particle = Particle {
                     position: [x, y],
                     age: rng.random_range(0.0..self.settings.particle_lifetime),
-                    color:  [0.0, 0.0, 0.0, 1.0],
+                    color: [0.0, 0.0, 0.0, 1.0],
                     my_parent_was: 0, // Autospawned
                 };
                 particles.push(particle);
@@ -3382,11 +3379,11 @@ impl FlowModel {
             address_mode_u: wgpu::AddressMode::ClampToEdge,
             address_mode_v: wgpu::AddressMode::ClampToEdge,
             address_mode_w: wgpu::AddressMode::ClampToEdge,
-            mag_filter: match self.settings.trail_map_filtering {
+            mag_filter: match self.trail_map_filtering {
                 super::settings::TrailMapFiltering::Nearest => wgpu::FilterMode::Nearest,
                 super::settings::TrailMapFiltering::Linear => wgpu::FilterMode::Linear,
             },
-            min_filter: match self.settings.trail_map_filtering {
+            min_filter: match self.trail_map_filtering {
                 super::settings::TrailMapFiltering::Nearest => wgpu::FilterMode::Nearest,
                 super::settings::TrailMapFiltering::Linear => wgpu::FilterMode::Linear,
             },
diff --git a/src-tauri/src/simulations/gradient/simulation.rs b/src-tauri/src/simulations/gradient/simulation.rs
index d0c58ef..86c42b5 100644
--- a/src-tauri/src/simulations/gradient/simulation.rs
+++ b/src-tauri/src/simulations/gradient/simulation.rs
@@ -1,23 +1,17 @@
 use crate::error::SimulationResult;
 use crate::simulations::gradient::shaders::GRADIENT_SHADER;
-use crate::simulations::shared::{
-    BindGroupBuilder, RenderPipelineBuilder, ShaderManager,
-    lut::LutData,
-};
+use crate::simulations::shared::{BindGroupBuilder, RenderPipelineBuilder, lut::LutData};
 use crate::simulations::traits::Simulation;
 use serde_json::Value;
 use std::sync::Arc;
 use wgpu::util::DeviceExt;
 use wgpu::{
-    BindGroup, Buffer, BufferUsages, Device, Queue, RenderPipeline, SurfaceConfiguration, 
+    BindGroup, Buffer, BufferUsages, Device, Queue, RenderPipeline, SurfaceConfiguration,
     TextureFormat, TextureView,
 };
 
 #[derive(Debug)]
 pub struct GradientSimulation {
-    // GPU utilities
-    shader_manager: ShaderManager,
-    
     render_pipeline: RenderPipeline,
     vertex_buffer: Buffer,
     index_buffer: Buffer,
@@ -34,9 +28,6 @@ pub struct GradientSimulation {
 
 impl GradientSimulation {
     pub fn new(device: &Device, queue: &Queue, format: TextureFormat) -> Self {
-        // Initialize GPU utilities
-        let mut shader_manager = ShaderManager::new();
-
         // Create vertex buffer for a full-screen quad
         let vertices: [f32; 16] = [
             -1.0, -1.0, 0.0, 0.0, // position, uv
@@ -113,7 +104,10 @@ impl GradientSimulation {
             .build();
 
         // Create render pipeline using GPU utilities
-        let shader = shader_manager.load_shader(device, "gradient", GRADIENT_SHADER);
+        let shader = Arc::new(device.create_shader_module(wgpu::ShaderModuleDescriptor {
+            label: Some("gradient"),
+            source: wgpu::ShaderSource::Wgsl(GRADIENT_SHADER.into()),
+        }));
 
         let render_pipeline = RenderPipelineBuilder::new(Arc::new(device.clone()))
             .with_shader(shader)
@@ -165,7 +159,6 @@ impl GradientSimulation {
         queue.write_buffer(&lut_buffer, 0, bytemuck::cast_slice(&default_lut));
 
         Self {
-            shader_manager,
             render_pipeline,
             vertex_buffer,
             index_buffer,
diff --git a/src-tauri/src/simulations/gray_scott/renderer.rs b/src-tauri/src/simulations/gray_scott/renderer.rs
index b4ccede..1f22918 100644
--- a/src-tauri/src/simulations/gray_scott/renderer.rs
+++ b/src-tauri/src/simulations/gray_scott/renderer.rs
@@ -18,11 +18,7 @@ pub struct Renderer {
     width: u32,
     height: u32,
     settings: Settings,
-    
-    // GPU utilities
-    shader_manager: ShaderManager,
-    common_layouts: CommonBindGroupLayouts,
-    
+
     lut_buffer: wgpu::Buffer,
     background_color_buffer: wgpu::Buffer,
     render_infinite_pipeline: wgpu::RenderPipeline,
@@ -156,7 +152,10 @@ impl Renderer {
         // Create infinite render pipeline using GPU utilities
         let render_infinite_pipeline = RenderPipelineBuilder::new(device.clone())
             .with_shader(shader_infinite)
-            .with_bind_group_layouts(vec![bind_group_layout.clone(), camera_bind_group_layout.clone()])
+            .with_bind_group_layouts(vec![
+                bind_group_layout.clone(),
+                camera_bind_group_layout.clone(),
+            ])
             .with_fragment_targets(vec![Some(wgpu::ColorTargetState {
                 format: surface_config.format,
                 blend: Some(wgpu::BlendState::ALPHA_BLENDING),
@@ -177,7 +176,10 @@ impl Renderer {
         // Create background render pipeline using GPU utilities
         let background_render_pipeline = RenderPipelineBuilder::new(device.clone())
             .with_shader(background_shader)
-            .with_bind_group_layouts(vec![background_bind_group_layout.clone(), camera_bind_group_layout.clone()])
+            .with_bind_group_layouts(vec![
+                background_bind_group_layout.clone(),
+                camera_bind_group_layout.clone(),
+            ])
             .with_fragment_targets(vec![Some(wgpu::ColorTargetState {
                 format: surface_config.format,
                 blend: Some(wgpu::BlendState::REPLACE),
@@ -202,8 +204,6 @@ impl Renderer {
             width,
             height,
             settings,
-            shader_manager,
-            common_layouts,
             lut_buffer,
             background_color_buffer,
             render_infinite_pipeline,
diff --git a/src-tauri/src/simulations/main_menu/simulation.rs b/src-tauri/src/simulations/main_menu/simulation.rs
index 84b3fae..6ebea73 100644
--- a/src-tauri/src/simulations/main_menu/simulation.rs
+++ b/src-tauri/src/simulations/main_menu/simulation.rs
@@ -1,6 +1,6 @@
 use crate::error::SimulationResult;
 use crate::simulations::shared::{
-    BindGroupBuilder, CommonBindGroupLayouts, RenderPipelineBuilder, ShaderManager, LutManager,
+    BindGroupBuilder, CommonBindGroupLayouts, LutManager, RenderPipelineBuilder,
 };
 use crate::simulations::traits::Simulation;
 use serde_json::Value;
@@ -11,10 +11,6 @@ use wgpu::{BindGroup, Buffer, Device, Queue, RenderPipeline, SurfaceConfiguratio
 
 #[derive(Debug)]
 pub struct MainMenuModel {
-    // GPU utilities
-    shader_manager: ShaderManager,
-    common_layouts: CommonBindGroupLayouts,
-    
     render_pipeline: RenderPipeline,
     time_buffer: Buffer,
     time_bind_group: BindGroup,
@@ -29,8 +25,7 @@ impl MainMenuModel {
         surface_config: &SurfaceConfiguration,
         lut_manager: &LutManager,
     ) -> SimulationResult<Self> {
-        // Initialize GPU utilities
-        let mut shader_manager = ShaderManager::new();
+        // Create common layouts
         let common_layouts = CommonBindGroupLayouts::new(device);
 
         // Create the time uniform buffer and bind group
@@ -65,16 +60,20 @@ impl MainMenuModel {
             .build();
 
         // Create shaders using GPU utilities
-        let combined_shader = shader_manager.load_shader(
-            device,
-            "main_menu_combined",
-            crate::simulations::main_menu::shaders::COMBINED_SHADER,
-        );
+        let combined_shader = Arc::new(device.create_shader_module(wgpu::ShaderModuleDescriptor {
+            label: Some("main_menu_combined"),
+            source: wgpu::ShaderSource::Wgsl(
+                crate::simulations::main_menu::shaders::COMBINED_SHADER.into(),
+            ),
+        }));
 
         // Create render pipeline using GPU utilities
         let render_pipeline = RenderPipelineBuilder::new(device.clone())
             .with_shader(combined_shader)
-            .with_bind_group_layouts(vec![time_bind_group_layout.clone(), lut_bind_group_layout.clone()])
+            .with_bind_group_layouts(vec![
+                time_bind_group_layout.clone(),
+                lut_bind_group_layout.clone(),
+            ])
             .with_fragment_targets(vec![Some(wgpu::ColorTargetState {
                 format: surface_config.format,
                 blend: Some(wgpu::BlendState::REPLACE),
@@ -95,8 +94,6 @@ impl MainMenuModel {
         let start_time = Instant::now();
 
         Ok(Self {
-            shader_manager,
-            common_layouts,
             render_pipeline,
             time_buffer,
             time_bind_group,
diff --git a/src-tauri/src/simulations/particle_life/settings.rs b/src-tauri/src/simulations/particle_life/settings.rs
index 954648b..b31d70f 100644
--- a/src-tauri/src/simulations/particle_life/settings.rs
+++ b/src-tauri/src/simulations/particle_life/settings.rs
@@ -41,9 +41,6 @@ pub struct Settings {
     /// Controls the amount of random thermal motion applied to particles
     /// Higher values create more chaotic, jittery movement
     pub brownian_motion: f32,
-    /// Trail map filtering mode.
-    /// Controls how trail textures are sampled during rendering
-    pub trail_map_filtering: TrailMapFiltering,
 }
 
 #[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
@@ -155,7 +152,6 @@ impl Default for Settings {
             min_distance: 0.001,
             max_distance: 0.01,
             brownian_motion: 0.5,
-            trail_map_filtering: TrailMapFiltering::Nearest,
         }
     }
 }
diff --git a/src-tauri/src/simulations/particle_life/shaders/fade_fragment.wgsl b/src-tauri/src/simulations/particle_life/shaders/fade_fragment.wgsl
index f15fd08..0f3ba31 100644
--- a/src-tauri/src/simulations/particle_life/shaders/fade_fragment.wgsl
+++ b/src-tauri/src/simulations/particle_life/shaders/fade_fragment.wgsl
@@ -6,9 +6,10 @@ struct VertexOutput {
 }
 
 struct FadeUniforms {
-    background_color: vec3<f32>,  // Background color to fade to
-    fade_alpha: f32,              // Alpha for fading effect (0.0 = full fade, 1.0 = no fade)
+    fade_amount: f32,             // Amount to subtract from alpha each frame (0.0 = no fade, higher = faster fade)
     _pad1: f32,                   // Padding for 16-byte alignment
+    _pad2: f32,                   // Padding for 16-byte alignment
+    _pad3: f32,                   // Padding for 16-byte alignment
 }
 
 @group(0) @binding(0) var<uniform> fade_uniforms: FadeUniforms;
@@ -20,11 +21,11 @@ fn main(input: VertexOutput) -> @location(0) vec4<f32> {
     // Sample from the display texture
     let tex_color = textureSample(display_tex, display_sampler, input.uv);
     
-    // Apply fade by blending towards background color
-    // fade_alpha controls how much of the original color to keep
-    // 0.0 = completely fade to background, 1.0 = keep original color
-    let faded_color = mix(fade_uniforms.background_color, tex_color.rgb, fade_uniforms.fade_alpha);
+    // Apply alpha fade by subtracting a fixed amount each frame
+    // fade_amount controls how much alpha to subtract per frame
+    // 0.0 = no fade, higher values = faster fade
+    let faded_alpha = max(tex_color.a - fade_uniforms.fade_amount, 0.0);
     
-    // Preserve the original alpha for proper blending
-    return vec4<f32>(faded_color, tex_color.a);
+    // Keep the original color but reduce the alpha
+    return vec4<f32>(tex_color.rgb, faded_alpha);
 } 
\ No newline at end of file
diff --git a/src-tauri/src/simulations/particle_life/simulation.rs b/src-tauri/src/simulations/particle_life/simulation.rs
index bfcda4b..6778ae0 100644
--- a/src-tauri/src/simulations/particle_life/simulation.rs
+++ b/src-tauri/src/simulations/particle_life/simulation.rs
@@ -1,7 +1,6 @@
 use crate::error::{SimulationError, SimulationResult};
 use crate::simulations::shared::{
-    BindGroupBuilder, CommonBindGroupLayouts, ComputePipelineBuilder, ShaderManager,
-    LutManager, PositionGenerator, camera::Camera,
+    BindGroupBuilder, ComputePipelineBuilder, LutManager, PositionGenerator, camera::Camera,
 };
 use bytemuck::{Pod, Zeroable};
 use rand::{Rng, SeedableRng};
@@ -60,12 +59,10 @@ pub struct ForceRandomizeParams {
 #[repr(C)]
 #[derive(Debug, Copy, Clone, Pod, Zeroable)]
 pub struct FadeUniforms {
-    pub background_color: [f32; 3], // Background color to fade to (RGB)
-    pub fade_alpha: f32, // Alpha for fading effect
-    pub _pad1: u32,
-    pub _pad2: u32,
-    pub _pad3: u32,
-    pub _pad4: u32,
+    pub fade_amount: f32, // Amount to subtract from alpha each frame (0.0 = no fade, higher = faster fade)
+    pub _pad1: f32,       // Padding for 16-byte alignment
+    pub _pad2: f32,       // Padding for 16-byte alignment
+    pub _pad3: f32,       // Padding for 16-byte alignment
 }
 
 #[repr(C)]
@@ -196,6 +193,9 @@ pub struct State {
     /// Particle size in world space units
     /// Controls the visual size of particles in the simulation
     pub particle_size: f32,
+    /// Trail map filtering mode.
+    /// Controls how trail textures are sampled during rendering
+    pub trail_map_filtering: super::settings::TrailMapFiltering,
 }
 
 impl State {
@@ -243,6 +243,7 @@ impl State {
             // Placeholder values - will be properly initialized when LUT is loaded in main constructor
             species_colors: vec![[0.0, 0.0, 0.0, 1.0]],
             particle_size: 0.1,
+            trail_map_filtering: super::settings::TrailMapFiltering::Nearest,
         }
     }
 }
@@ -260,10 +261,6 @@ pub enum ColorMode {
 /// Particle Life simulation model
 #[derive(Debug)]
 pub struct ParticleLifeModel {
-    // GPU utilities
-    shader_manager: ShaderManager,
-    common_layouts: CommonBindGroupLayouts,
-    
     // GPU resources
     pub particle_buffer: wgpu::Buffer,
     pub sim_params_buffer: wgpu::Buffer,
@@ -321,9 +318,12 @@ pub struct ParticleLifeModel {
     pub fade_bind_group: wgpu::BindGroup,
     pub fade_uniforms_buffer: wgpu::Buffer,
 
-    // Trail texture for persistent trails
-    pub trail_texture: wgpu::Texture,
-    pub trail_texture_view: wgpu::TextureView,
+    // Trail textures for persistent trails (ping-pong buffers)
+    pub trail_texture_a: wgpu::Texture,
+    pub trail_texture_view_a: wgpu::TextureView,
+    pub trail_texture_b: wgpu::Texture,
+    pub trail_texture_view_b: wgpu::TextureView,
+    pub current_trail_is_a: bool, // true = A is current write target, B is read source
 
     // Blit pipeline to copy trail texture to surface
     pub blit_pipeline: wgpu::RenderPipeline,
@@ -534,6 +534,57 @@ impl ParticleLifeModel {
                 .msaa_texture
                 .create_view(&wgpu::TextureViewDescriptor::default());
 
+            // Recreate trail textures with new dimensions
+            self.trail_texture_a = device.create_texture(&wgpu::TextureDescriptor {
+                label: Some("Trail Texture A"),
+                size: wgpu::Extent3d {
+                    width: new_width,
+                    height: new_height,
+                    depth_or_array_layers: 1,
+                },
+                mip_level_count: 1,
+                sample_count: 1,
+                dimension: wgpu::TextureDimension::D2,
+                format: wgpu::TextureFormat::Rgba8Unorm,
+                usage: wgpu::TextureUsages::RENDER_ATTACHMENT
+                    | wgpu::TextureUsages::TEXTURE_BINDING,
+                view_formats: &[],
+            });
+
+            self.trail_texture_view_a =
+                self.trail_texture_a
+                    .create_view(&wgpu::TextureViewDescriptor {
+                        label: Some("Trail Texture View A"),
+                        dimension: Some(wgpu::TextureViewDimension::D2),
+                        format: Some(wgpu::TextureFormat::Rgba8Unorm),
+                        ..Default::default()
+                    });
+
+            self.trail_texture_b = device.create_texture(&wgpu::TextureDescriptor {
+                label: Some("Trail Texture B"),
+                size: wgpu::Extent3d {
+                    width: new_width,
+                    height: new_height,
+                    depth_or_array_layers: 1,
+                },
+                mip_level_count: 1,
+                sample_count: 1,
+                dimension: wgpu::TextureDimension::D2,
+                format: wgpu::TextureFormat::Rgba8Unorm,
+                usage: wgpu::TextureUsages::RENDER_ATTACHMENT
+                    | wgpu::TextureUsages::TEXTURE_BINDING,
+                view_formats: &[],
+            });
+
+            self.trail_texture_view_b =
+                self.trail_texture_b
+                    .create_view(&wgpu::TextureViewDescriptor {
+                        label: Some("Trail Texture View B"),
+                        dimension: Some(wgpu::TextureViewDimension::D2),
+                        format: Some(wgpu::TextureFormat::Rgba8Unorm),
+                        ..Default::default()
+                    });
+
             // Update dimensions
             self.width = new_width;
             self.height = new_height;
@@ -726,6 +777,7 @@ impl ParticleLifeModel {
             color_mode,
             species_colors: lut_colors.clone(),
             particle_size: 4.0,
+            trail_map_filtering: super::settings::TrailMapFiltering::Nearest,
         };
 
         // Check buffer size limits
@@ -739,10 +791,6 @@ impl ParticleLifeModel {
             });
         }
 
-        // Initialize GPU utilities
-        let mut shader_manager = ShaderManager::new();
-        let common_layouts = CommonBindGroupLayouts::new(device);
-
         // Create empty particle buffer (will be initialized on GPU)
         let particle_buffer = device.create_buffer(&wgpu::BufferDescriptor {
             label: Some("Particle Buffer"),
@@ -783,11 +831,10 @@ impl ParticleLifeModel {
         );
 
         // Create compute shader and pipeline using GPU utilities
-        let compute_shader = shader_manager.load_shader(
-            device,
-            "particle_life_compute",
-            shaders::COMPUTE_SHADER,
-        );
+        let compute_shader = Arc::new(device.create_shader_module(wgpu::ShaderModuleDescriptor {
+            label: Some("particle_life_compute"),
+            source: wgpu::ShaderSource::Wgsl(shaders::COMPUTE_SHADER.into()),
+        }));
 
         let compute_bind_group_layout =
             device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
@@ -840,11 +887,10 @@ impl ParticleLifeModel {
             .build();
 
         // Create initialization compute shader and pipeline using GPU utilities
-        let init_shader = shader_manager.load_shader(
-            device,
-            "particle_life_init",
-            shaders::INIT_SHADER,
-        );
+        let init_shader = Arc::new(device.create_shader_module(wgpu::ShaderModuleDescriptor {
+            label: Some("particle_life_init"),
+            source: wgpu::ShaderSource::Wgsl(shaders::INIT_SHADER.into()),
+        }));
 
         let init_bind_group_layout =
             device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
@@ -906,11 +952,11 @@ impl ParticleLifeModel {
             .build();
 
         // Create force update compute shader and pipeline using GPU utilities
-        let force_update_shader = shader_manager.load_shader(
-            device,
-            "particle_life_force_update",
-            shaders::FORCE_UPDATE_SHADER,
-        );
+        let force_update_shader =
+            Arc::new(device.create_shader_module(wgpu::ShaderModuleDescriptor {
+                label: Some("particle_life_force_update"),
+                source: wgpu::ShaderSource::Wgsl(shaders::FORCE_UPDATE_SHADER.into()),
+            }));
 
         let force_update_params = ForceUpdateParams {
             species_a: 0,
@@ -958,18 +1004,19 @@ impl ParticleLifeModel {
             .with_label("Force Update Pipeline".to_string())
             .build();
 
-        let force_update_bind_group = BindGroupBuilder::new(device, &force_update_bind_group_layout)
-            .add_buffer(0, &force_matrix_buffer)
-            .add_buffer(1, &force_update_params_buffer)
-            .with_label("Force Update Bind Group".to_string())
-            .build();
+        let force_update_bind_group =
+            BindGroupBuilder::new(device, &force_update_bind_group_layout)
+                .add_buffer(0, &force_matrix_buffer)
+                .add_buffer(1, &force_update_params_buffer)
+                .with_label("Force Update Bind Group".to_string())
+                .build();
 
         // Create force randomization compute shader and pipeline using GPU utilities
-        let force_randomize_shader = shader_manager.load_shader(
-            device,
-            "particle_life_force_randomize",
-            shaders::FORCE_RANDOMIZE_SHADER,
-        );
+        let force_randomize_shader =
+            Arc::new(device.create_shader_module(wgpu::ShaderModuleDescriptor {
+                label: Some("particle_life_force_randomize"),
+                source: wgpu::ShaderSource::Wgsl(shaders::FORCE_RANDOMIZE_SHADER.into()),
+            }));
 
         let force_randomize_params = ForceRandomizeParams {
             species_count: settings.species_count,
@@ -1017,11 +1064,12 @@ impl ParticleLifeModel {
             .with_label("Force Randomize Pipeline".to_string())
             .build();
 
-        let force_randomize_bind_group = BindGroupBuilder::new(device, &force_randomize_bind_group_layout)
-            .add_buffer(0, &force_matrix_buffer)
-            .add_buffer(1, &force_randomize_params_buffer)
-            .with_label("Force Randomize Bind Group".to_string())
-            .build();
+        let force_randomize_bind_group =
+            BindGroupBuilder::new(device, &force_randomize_bind_group_layout)
+                .add_buffer(0, &force_matrix_buffer)
+                .add_buffer(1, &force_randomize_params_buffer)
+                .with_label("Force Randomize Bind Group".to_string())
+                .build();
 
         // Create render shaders and pipeline
         let vertex_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
@@ -1349,8 +1397,8 @@ impl ParticleLifeModel {
                     module: &fragment_shader,
                     entry_point: Some("main"),
                     targets: &[Some(wgpu::ColorTargetState {
-                        format: surface_config.format,
-                        blend: Some(wgpu::BlendState::REPLACE),
+                        format: wgpu::TextureFormat::Rgba8Unorm, // Use RGBA format for proper alpha support
+                        blend: Some(wgpu::BlendState::ALPHA_BLENDING), // Use alpha blending for trails
                         write_mask: wgpu::ColorWrites::ALL,
                     })],
                     compilation_options: Default::default(),
@@ -1587,7 +1635,7 @@ impl ParticleLifeModel {
                 module: &fade_fragment_shader,
                 entry_point: Some("main"),
                 targets: &[Some(wgpu::ColorTargetState {
-                    format: surface_config.format,
+                    format: wgpu::TextureFormat::Rgba8Unorm, // Use RGBA format to match trail texture
                     blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                     write_mask: wgpu::ColorWrites::ALL,
                 })],
@@ -1610,12 +1658,10 @@ impl ParticleLifeModel {
 
         // Create fade uniforms buffer
         let fade_uniforms = FadeUniforms {
-            background_color: [0.0, 0.0, 0.0], // Default to black background
-            fade_alpha: 0.1,
-            _pad1: 0,
-            _pad2: 0,
-            _pad3: 0,
-            _pad4: 0,
+            fade_amount: 0.01,
+            _pad1: 0.0,
+            _pad2: 0.0,
+            _pad3: 0.0,
         };
 
         let fade_uniforms_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
@@ -1674,9 +1720,31 @@ impl ParticleLifeModel {
             ],
         });
 
-        // Trail texture for persistent trails
-        let trail_texture = device.create_texture(&wgpu::TextureDescriptor {
-            label: Some("Trail Texture"),
+        // Trail textures for persistent trails (ping-pong buffers)
+        let trail_texture_a = device.create_texture(&wgpu::TextureDescriptor {
+            label: Some("Trail Texture A"),
+            size: wgpu::Extent3d {
+                width,
+                height,
+                depth_or_array_layers: 1,
+            },
+            mip_level_count: 1,
+            sample_count: 1,
+            dimension: wgpu::TextureDimension::D2,
+            format: wgpu::TextureFormat::Rgba8Unorm, // Use RGBA format for proper alpha support
+            usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING,
+            view_formats: &[],
+        });
+
+        let trail_texture_view_a = trail_texture_a.create_view(&wgpu::TextureViewDescriptor {
+            label: Some("Trail Texture View A"),
+            dimension: Some(wgpu::TextureViewDimension::D2),
+            format: Some(wgpu::TextureFormat::Rgba8Unorm), // Use RGBA format for proper alpha support
+            ..Default::default()
+        });
+
+        let trail_texture_b = device.create_texture(&wgpu::TextureDescriptor {
+            label: Some("Trail Texture B"),
             size: wgpu::Extent3d {
                 width,
                 height,
@@ -1685,16 +1753,15 @@ impl ParticleLifeModel {
             mip_level_count: 1,
             sample_count: 1,
             dimension: wgpu::TextureDimension::D2,
-            format: surface_config.format,
+            format: wgpu::TextureFormat::Rgba8Unorm, // Use RGBA format for proper alpha support
             usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING,
             view_formats: &[],
         });
 
-        // Trail texture view
-        let trail_texture_view = trail_texture.create_view(&wgpu::TextureViewDescriptor {
-            label: Some("Trail Texture View"),
+        let trail_texture_view_b = trail_texture_b.create_view(&wgpu::TextureViewDescriptor {
+            label: Some("Trail Texture View B"),
             dimension: Some(wgpu::TextureViewDimension::D2),
-            format: Some(surface_config.format),
+            format: Some(wgpu::TextureFormat::Rgba8Unorm), // Use RGBA format for proper alpha support
             ..Default::default()
         });
 
@@ -1861,14 +1928,14 @@ impl ParticleLifeModel {
             ..Default::default()
         });
 
-        // Blit bind group
+        // Blit bind group (initially uses texture A)
         let blit_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
             label: Some("Blit Bind Group"),
             layout: &blit_bind_group_layout,
             entries: &[
                 wgpu::BindGroupEntry {
                     binding: 0,
-                    resource: wgpu::BindingResource::TextureView(&trail_texture_view),
+                    resource: wgpu::BindingResource::TextureView(&trail_texture_view_a),
                 },
                 wgpu::BindGroupEntry {
                     binding: 1,
@@ -2276,8 +2343,6 @@ impl ParticleLifeModel {
             });
 
         let mut result = Self {
-            shader_manager,
-            common_layouts,
             particle_buffer: particle_buffer.clone(),
             sim_params_buffer: sim_params_buffer.clone(),
             force_matrix_buffer,
@@ -2351,8 +2416,11 @@ impl ParticleLifeModel {
             fade_bind_group_layout,
             fade_bind_group,
             fade_uniforms_buffer,
-            trail_texture,
-            trail_texture_view,
+            trail_texture_a,
+            trail_texture_view_a,
+            trail_texture_b,
+            trail_texture_view_b,
+            current_trail_is_a: true,
             blit_pipeline,
             display_blit_pipeline,
             blit_bind_group_layout,
@@ -2431,7 +2499,7 @@ impl ParticleLifeModel {
             ColorMode::White => wgpu::Color::WHITE,
             ColorMode::Black => wgpu::Color::BLACK,
             ColorMode::Lut => {
-                if let Some(&[r, g, b, a]) = result.state.species_colors.last() {
+                if let Some(&[r, g, b, a]) = result.state.species_colors.first() {
                     wgpu::Color {
                         r: r.into(),
                         g: g.into(),
@@ -2863,29 +2931,12 @@ impl ParticleLifeModel {
     }
 
     /// Update fade uniforms for trace rendering
-    fn update_fade_uniforms(&self, queue: &Arc<Queue>, fade_alpha: f32) {
-        // Get background color based on color mode
-        let background_color = match self.state.color_mode {
-            ColorMode::Black => [0.0, 0.0, 0.0],     // Black
-            ColorMode::White => [1.0, 1.0, 1.0],     // White
-            ColorMode::Gray18 => [0.18, 0.18, 0.18], // Gray18
-            ColorMode::Lut => {
-                // Use first color from species_colors (which includes background color)
-                if !self.state.species_colors.is_empty() {
-                    [self.state.species_colors[0][0], self.state.species_colors[0][1], self.state.species_colors[0][2]]
-                } else {
-                    [0.0, 0.0, 0.0] // Fallback to black
-                }
-            }
-        };
-
+    fn update_fade_uniforms(&self, queue: &Arc<Queue>, fade_amount: f32) {
         let fade_uniforms = FadeUniforms {
-            background_color,
-            fade_alpha,
-            _pad1: 0,
-            _pad2: 0,
-            _pad3: 0,
-            _pad4: 0,
+            fade_amount,
+            _pad1: 0.0,
+            _pad2: 0.0,
+            _pad3: 0.0,
         };
 
         queue.write_buffer(
@@ -2896,6 +2947,9 @@ impl ParticleLifeModel {
     }
 
     fn update_fade_bind_group(&mut self, device: &Arc<Device>) {
+        // Read from the previous trail texture (opposite of current write target)
+        let read_texture_view = self.get_read_trail_texture_view();
+
         self.fade_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
             label: Some("Fade Bind Group"),
             layout: &self.fade_bind_group_layout,
@@ -2906,7 +2960,7 @@ impl ParticleLifeModel {
                 },
                 wgpu::BindGroupEntry {
                     binding: 1,
-                    resource: wgpu::BindingResource::TextureView(&self.display_view),
+                    resource: wgpu::BindingResource::TextureView(read_texture_view),
                 },
                 wgpu::BindGroupEntry {
                     binding: 2,
@@ -2916,6 +2970,50 @@ impl ParticleLifeModel {
         });
     }
 
+    /// Get the trail texture view to write to (render target)
+    fn get_write_trail_texture_view(&self) -> &wgpu::TextureView {
+        if self.current_trail_is_a {
+            &self.trail_texture_view_a
+        } else {
+            &self.trail_texture_view_b
+        }
+    }
+
+    /// Get the trail texture view to read from (for fade shader)
+    fn get_read_trail_texture_view(&self) -> &wgpu::TextureView {
+        if self.current_trail_is_a {
+            &self.trail_texture_view_b // Read from B when writing to A
+        } else {
+            &self.trail_texture_view_a // Read from A when writing to B
+        }
+    }
+
+    /// Swap the ping-pong trail textures after each frame
+    fn swap_trail_textures(&mut self) {
+        self.current_trail_is_a = !self.current_trail_is_a;
+    }
+
+    /// Update blit bind group to read from the current completed trail texture
+    fn update_blit_bind_group(&mut self, device: &Arc<Device>) {
+        // For blitting, we want to read from the texture we just finished writing to
+        let read_texture_view = self.get_write_trail_texture_view();
+
+        self.blit_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
+            label: Some("Blit Bind Group"),
+            layout: &self.blit_bind_group_layout,
+            entries: &[
+                wgpu::BindGroupEntry {
+                    binding: 0,
+                    resource: wgpu::BindingResource::TextureView(read_texture_view),
+                },
+                wgpu::BindGroupEntry {
+                    binding: 1,
+                    resource: wgpu::BindingResource::Sampler(&self.display_sampler),
+                },
+            ],
+        });
+    }
+
     /// Update background color based on color mode
     pub fn update_background_params(&mut self, queue: &Arc<Queue>) {
         // Get background color based on color mode
@@ -2952,11 +3050,30 @@ impl ParticleLifeModel {
         let mut encoder = device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
             label: Some("Clear Trail Texture Encoder"),
         });
+
+        // Clear both trail textures
+        {
+            let _render_pass_a = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
+                label: Some("Clear Trail Texture A Pass"),
+                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
+                    view: &self.trail_texture_view_a,
+                    resolve_target: None,
+                    ops: wgpu::Operations {
+                        load: wgpu::LoadOp::Clear(background_color),
+                        store: wgpu::StoreOp::Store,
+                    },
+                })],
+                depth_stencil_attachment: None,
+                timestamp_writes: None,
+                occlusion_query_set: None,
+            });
+        }
+
         {
-            let _render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
-                label: Some("Clear Trail Texture Pass"),
+            let _render_pass_b = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
+                label: Some("Clear Trail Texture B Pass"),
                 color_attachments: &[Some(wgpu::RenderPassColorAttachment {
-                    view: &self.trail_texture_view,
+                    view: &self.trail_texture_view_b,
                     resolve_target: None,
                     ops: wgpu::Operations {
                         load: wgpu::LoadOp::Clear(background_color),
@@ -3064,11 +3181,12 @@ impl Simulation for ParticleLifeModel {
 
         // Step 2: Render particles to display texture (offscreen)
         if self.state.traces_enabled {
-            // When trails are enabled, render to trail texture first
+            // For static rendering, just render to current trail texture without fade
+            let write_texture_view = self.get_write_trail_texture_view();
             let mut trail_render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                 label: Some("Static Trail Render Pass"),
                 color_attachments: &[Some(wgpu::RenderPassColorAttachment {
-                    view: &self.trail_texture_view,
+                    view: write_texture_view,
                     resolve_target: None,
                     ops: wgpu::Operations {
                         load: wgpu::LoadOp::Load, // Preserve previous trail content
@@ -3125,7 +3243,7 @@ impl Simulation for ParticleLifeModel {
                 occlusion_query_set: None,
             });
 
-            display_render_pass.set_pipeline(&self.offscreen_render_pipeline);
+            display_render_pass.set_pipeline(&self.display_render_pipeline);
             display_render_pass.set_bind_group(0, &self.render_bind_group, &[]);
             display_render_pass.set_bind_group(1, &self.lut_bind_group, &[]);
             display_render_pass.set_bind_group(2, &self.camera_bind_group, &[]);
@@ -3230,16 +3348,19 @@ impl Simulation for ParticleLifeModel {
         // Update background parameters
         self.update_background_params(queue);
 
-        let mut encoder = device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
-            label: Some("Particle Life Render Encoder"),
+        // Use separate command encoders to avoid texture usage conflicts
+        // First encoder: compute and trail rendering
+        let mut compute_encoder = device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
+            label: Some("Particle Life Compute Encoder"),
         });
 
         // Single physics step per frame for proper timing
         {
-            let mut compute_pass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor {
-                label: Some("Particle Life Compute Pass"),
-                timestamp_writes: None,
-            });
+            let mut compute_pass =
+                compute_encoder.begin_compute_pass(&wgpu::ComputePassDescriptor {
+                    label: Some("Particle Life Compute Pass"),
+                    timestamp_writes: None,
+                });
 
             compute_pass.set_pipeline(&self.compute_pipeline);
             compute_pass.set_bind_group(0, &self.compute_bind_group, &[]);
@@ -3251,20 +3372,21 @@ impl Simulation for ParticleLifeModel {
 
         // Step 1: Render background to display texture (offscreen)
         {
-            let mut background_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
-                label: Some("Background Render Pass"),
-                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
-                    view: &self.display_view,
-                    resolve_target: None,
-                    ops: wgpu::Operations {
-                        load: wgpu::LoadOp::Clear(wgpu::Color::TRANSPARENT), // Clear to transparent, background shader will fill
-                        store: wgpu::StoreOp::Store,
-                    },
-                })],
-                depth_stencil_attachment: None,
-                timestamp_writes: None,
-                occlusion_query_set: None,
-            });
+            let mut background_pass =
+                compute_encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
+                    label: Some("Background Render Pass"),
+                    color_attachments: &[Some(wgpu::RenderPassColorAttachment {
+                        view: &self.display_view,
+                        resolve_target: None,
+                        ops: wgpu::Operations {
+                            load: wgpu::LoadOp::Clear(wgpu::Color::TRANSPARENT), // Clear to transparent, background shader will fill
+                            store: wgpu::StoreOp::Store,
+                        },
+                    })],
+                    depth_stencil_attachment: None,
+                    timestamp_writes: None,
+                    occlusion_query_set: None,
+                });
 
             background_pass.set_pipeline(&self.background_render_pipeline);
             background_pass.set_bind_group(0, &self.background_bind_group, &[]);
@@ -3273,34 +3395,86 @@ impl Simulation for ParticleLifeModel {
 
         // Step 2: Render particles to display texture (offscreen)
         if self.state.traces_enabled {
+            // Update bind groups for ping-pong rendering
+            self.update_fade_bind_group(device);
+
             // When trails are enabled, render to trail texture first
-            let mut trail_render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
-                label: Some("Trail Render Pass"),
-                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
-                    view: &self.trail_texture_view,
-                    resolve_target: None,
-                    ops: wgpu::Operations {
-                        load: wgpu::LoadOp::Load, // Preserve previous trail content
-                        store: wgpu::StoreOp::Store,
-                    },
-                })],
-                depth_stencil_attachment: None,
-                timestamp_writes: None,
-                occlusion_query_set: None,
-            });
+            // Use ping-pong textures to avoid read/write conflicts
+            let write_texture_view = self.get_write_trail_texture_view();
+
+            // Get background color for clearing
+            let background_color = match self.state.color_mode {
+                ColorMode::Black => wgpu::Color {
+                    r: 0.0,
+                    g: 0.0,
+                    b: 0.0,
+                    a: 1.0,
+                },
+                ColorMode::White => wgpu::Color {
+                    r: 1.0,
+                    g: 1.0,
+                    b: 1.0,
+                    a: 1.0,
+                },
+                ColorMode::Gray18 => wgpu::Color {
+                    r: 0.18,
+                    g: 0.18,
+                    b: 0.18,
+                    a: 1.0,
+                },
+                ColorMode::Lut => {
+                    if !self.state.species_colors.is_empty() {
+                        let bg = self.state.species_colors[0];
+                        wgpu::Color {
+                            r: bg[0] as f64,
+                            g: bg[1] as f64,
+                            b: bg[2] as f64,
+                            a: bg[3] as f64,
+                        }
+                    } else {
+                        wgpu::Color {
+                            r: 0.0,
+                            g: 0.0,
+                            b: 0.0,
+                            a: 1.0,
+                        }
+                    }
+                }
+            };
 
-            // First, apply fade effect if trace_fade < 1.0
-            if self.state.trace_fade < 1.0 {
-                // Calculate fade alpha: 0.0 = full fade to background, 1.0 = no fade
-                // Use a smoother curve that provides better visual results
-                let fade_alpha = self.state.trace_fade.powf(0.7).clamp(0.1, 1.0);
+            let mut trail_render_pass =
+                compute_encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
+                    label: Some("Trail Render Pass"),
+                    color_attachments: &[Some(wgpu::RenderPassColorAttachment {
+                        view: write_texture_view,
+                        resolve_target: None,
+                        ops: wgpu::Operations {
+                            load: wgpu::LoadOp::Clear(background_color), // Clear with background color
+                            store: wgpu::StoreOp::Store,
+                        },
+                    })],
+                    depth_stencil_attachment: None,
+                    timestamp_writes: None,
+                    occlusion_query_set: None,
+                });
+
+            // Always copy previous trail content (with or without fading)
+            // Calculate fade amount: convert trace_fade (0-1) to subtraction amount per frame
+            let fade_amount = if self.state.trace_fade < 1.0 {
+                // Invert trace_fade so 0.0 = fast fade, 1.0 = no fade
+                // Scale to reasonable subtraction range (0.001 to 0.1 per frame)
+                let fade_strength = 1.0 - self.state.trace_fade;
+                fade_strength * 0.1 // Maximum fade of 0.1 alpha per frame
+            } else {
+                0.0 // No fading
+            };
 
-                self.update_fade_uniforms(queue, fade_alpha);
+            self.update_fade_uniforms(queue, fade_amount);
 
-                trail_render_pass.set_pipeline(&self.fade_pipeline);
-                trail_render_pass.set_bind_group(0, &self.fade_bind_group, &[]);
-                trail_render_pass.draw(0..3, 0..1);
-            }
+            // Apply fade effect - reads from previous texture, writes to current
+            trail_render_pass.set_pipeline(&self.fade_pipeline);
+            trail_render_pass.set_bind_group(0, &self.fade_bind_group, &[]);
+            trail_render_pass.draw(0..3, 0..1);
 
             // Then render particles on top
             trail_render_pass.set_pipeline(&self.trail_render_pipeline);
@@ -3311,42 +3485,23 @@ impl Simulation for ParticleLifeModel {
             let particle_count = self.state.particle_count as u32;
             trail_render_pass.draw(0..6, 0..particle_count);
             drop(trail_render_pass);
-
-            // Now blit trail texture to display texture
-            let mut display_render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
-                label: Some("Display Render Pass"),
-                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
-                    view: &self.display_view,
-                    resolve_target: None,
-                    ops: wgpu::Operations {
-                        load: wgpu::LoadOp::Load, // Load existing background
-                        store: wgpu::StoreOp::Store,
-                    },
-                })],
-                depth_stencil_attachment: None,
-                timestamp_writes: None,
-                occlusion_query_set: None,
-            });
-
-            display_render_pass.set_pipeline(&self.display_blit_pipeline);
-            display_render_pass.set_bind_group(0, &self.blit_bind_group, &[]);
-            display_render_pass.draw(0..3, 0..1);
         } else {
             // When trails are disabled, render particles directly to display texture (preserving background)
-            let mut particle_render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
-                label: Some("Particle Render Pass"),
-                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
-                    view: &self.display_view,
-                    resolve_target: None,
-                    ops: wgpu::Operations {
-                        load: wgpu::LoadOp::Load, // Preserve background
-                        store: wgpu::StoreOp::Store,
-                    },
-                })],
-                depth_stencil_attachment: None,
-                timestamp_writes: None,
-                occlusion_query_set: None,
-            });
+            let mut particle_render_pass =
+                compute_encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
+                    label: Some("Particle Render Pass"),
+                    color_attachments: &[Some(wgpu::RenderPassColorAttachment {
+                        view: &self.display_view,
+                        resolve_target: None,
+                        ops: wgpu::Operations {
+                            load: wgpu::LoadOp::Load, // Preserve background
+                            store: wgpu::StoreOp::Store,
+                        },
+                    })],
+                    depth_stencil_attachment: None,
+                    timestamp_writes: None,
+                    occlusion_query_set: None,
+                });
 
             particle_render_pass.set_pipeline(&self.display_render_pipeline);
             particle_render_pass.set_bind_group(0, &self.render_bind_group, &[]);
@@ -3357,23 +3512,58 @@ impl Simulation for ParticleLifeModel {
             particle_render_pass.draw(0..6, 0..particle_count);
         }
 
+        // Submit the first encoder to ensure trail texture writes are complete
+        queue.submit(std::iter::once(compute_encoder.finish()));
+
+        // Second encoder: blit and final rendering (can now safely read trail texture)
+        let mut render_encoder = device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
+            label: Some("Particle Life Render Encoder"),
+        });
+
+        // Blit trail texture to display texture if trails are enabled
+        if self.state.traces_enabled {
+            // Update blit bind group to read from the texture we just wrote to
+            self.update_blit_bind_group(device);
+
+            let mut display_render_pass =
+                render_encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
+                    label: Some("Display Render Pass"),
+                    color_attachments: &[Some(wgpu::RenderPassColorAttachment {
+                        view: &self.display_view,
+                        resolve_target: None,
+                        ops: wgpu::Operations {
+                            load: wgpu::LoadOp::Load, // Load existing background
+                            store: wgpu::StoreOp::Store,
+                        },
+                    })],
+                    depth_stencil_attachment: None,
+                    timestamp_writes: None,
+                    occlusion_query_set: None,
+                });
+
+            display_render_pass.set_pipeline(&self.display_blit_pipeline);
+            display_render_pass.set_bind_group(0, &self.blit_bind_group, &[]);
+            display_render_pass.draw(0..3, 0..1);
+        }
+
         // Step 3: Render post effects from display texture to post-effect texture (offscreen)
         // Skip expensive post-effect pass when using default parameters
         if self.needs_post_effects() {
-            let mut post_effect_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
-                label: Some("Post Effect Render Pass"),
-                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
-                    view: &self.post_effect_view,
-                    resolve_target: None,
-                    ops: wgpu::Operations {
-                        load: wgpu::LoadOp::Clear(wgpu::Color::BLACK),
-                        store: wgpu::StoreOp::Store,
-                    },
-                })],
-                depth_stencil_attachment: None,
-                timestamp_writes: None,
-                occlusion_query_set: None,
-            });
+            let mut post_effect_pass =
+                render_encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
+                    label: Some("Post Effect Render Pass"),
+                    color_attachments: &[Some(wgpu::RenderPassColorAttachment {
+                        view: &self.post_effect_view,
+                        resolve_target: None,
+                        ops: wgpu::Operations {
+                            load: wgpu::LoadOp::Clear(wgpu::Color::BLACK),
+                            store: wgpu::StoreOp::Store,
+                        },
+                    })],
+                    depth_stencil_attachment: None,
+                    timestamp_writes: None,
+                    occlusion_query_set: None,
+                });
 
             post_effect_pass.set_pipeline(&self.post_effect_pipeline);
             post_effect_pass.set_bind_group(0, &self.post_effect_bind_group, &[]);
@@ -3386,20 +3576,21 @@ impl Simulation for ParticleLifeModel {
             let tile_count = Self::calculate_tile_count(self.camera.zoom);
             let total_instances = (tile_count * tile_count) as u32;
 
-            let mut surface_render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
-                label: Some("Surface Render Pass"),
-                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
-                    view: surface_view,
-                    resolve_target: None,
-                    ops: wgpu::Operations {
-                        load: wgpu::LoadOp::Load,
-                        store: wgpu::StoreOp::Store,
-                    },
-                })],
-                depth_stencil_attachment: None,
-                timestamp_writes: None,
-                occlusion_query_set: None,
-            });
+            let mut surface_render_pass =
+                render_encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
+                    label: Some("Surface Render Pass"),
+                    color_attachments: &[Some(wgpu::RenderPassColorAttachment {
+                        view: surface_view,
+                        resolve_target: None,
+                        ops: wgpu::Operations {
+                            load: wgpu::LoadOp::Load,
+                            store: wgpu::StoreOp::Store,
+                        },
+                    })],
+                    depth_stencil_attachment: None,
+                    timestamp_writes: None,
+                    occlusion_query_set: None,
+                });
 
             surface_render_pass.set_pipeline(&self.render_infinite_pipeline);
             surface_render_pass.set_bind_group(0, &self.render_infinite_display_bind_group, &[]);
@@ -3409,7 +3600,12 @@ impl Simulation for ParticleLifeModel {
             surface_render_pass.draw(0..6, 0..total_instances);
         }
 
-        queue.submit(std::iter::once(encoder.finish()));
+        queue.submit(std::iter::once(render_encoder.finish()));
+
+        // Swap ping-pong trail textures for next frame (only if trails are enabled)
+        if self.state.traces_enabled {
+            self.swap_trail_textures();
+        }
 
         Ok(())
     }
@@ -3750,6 +3946,7 @@ impl Simulation for ParticleLifeModel {
             "lut_reversed": self.state.lut_reversed,
             "color_mode": self.state.color_mode,
             "particle_size": self.state.particle_size,
+            "trail_map_filtering": self.state.trail_map_filtering,
         })
     }
 
diff --git a/src-tauri/src/simulations/particle_life/tests.rs b/src-tauri/src/simulations/particle_life/tests.rs
index 5713f2b..b2aa98d 100644
--- a/src-tauri/src/simulations/particle_life/tests.rs
+++ b/src-tauri/src/simulations/particle_life/tests.rs
@@ -734,12 +734,10 @@ fn test_struct_layout_consistency() {
         };
 
         let dummy_fade_uniforms = FadeUniforms {
-            background_color: [0.0, 0.0, 0.0],
-            fade_alpha: 0.1,
-            _pad1: 0,
-            _pad2: 0,
-            _pad3: 0,
-            _pad4: 0,
+            fade_amount: 0.01,
+            _pad1: 0.0,
+            _pad2: 0.0,
+            _pad3: 0.0,
         };
 
         let dummy_init_params = InitParams {
diff --git a/src-tauri/src/simulations/pellets/simulation.rs b/src-tauri/src/simulations/pellets/simulation.rs
index 25209f0..410e78c 100644
--- a/src-tauri/src/simulations/pellets/simulation.rs
+++ b/src-tauri/src/simulations/pellets/simulation.rs
@@ -20,8 +20,8 @@
 
 use crate::error::{SimulationError, SimulationResult};
 use crate::simulations::shared::{
-    BindGroupBuilder, CommonBindGroupLayouts, ComputePipelineBuilder, RenderPipelineBuilder, ShaderManager,
-    AverageColorResources, LutManager, camera::Camera,
+    AverageColorResources, BindGroupBuilder, ComputePipelineBuilder, LutManager,
+    RenderPipelineBuilder, camera::Camera,
 };
 use bytemuck::{Pod, Zeroable};
 use serde_json::Value;
@@ -130,10 +130,6 @@ pub struct GridCell {
 // GPU-based physics implementation - no Rapier needed
 
 pub struct PelletsModel {
-    // GPU utilities
-    shader_manager: ShaderManager,
-    common_layouts: CommonBindGroupLayouts,
-    
     // GPU resources
     pub particle_buffer: wgpu::Buffer,
     pub physics_params_buffer: wgpu::Buffer,
@@ -225,10 +221,6 @@ impl PelletsModel {
         // Initialize particles
         let particles = Self::initialize_particles(settings.particle_count, &settings);
 
-        // Initialize GPU utilities
-        let mut shader_manager = ShaderManager::new();
-        let common_layouts = CommonBindGroupLayouts::new(device);
-
         // Create buffers
         let particle_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
             label: Some("Pellets Particle Buffer"),
@@ -372,11 +364,10 @@ impl PelletsModel {
         });
 
         // Create render shaders using GPU utilities
-        let render_shader = shader_manager.load_shader(
-            device,
-            "pellets_render",
-            super::shaders::PARTICLE_RENDER_SHADER,
-        );
+        let render_shader = Arc::new(device.create_shader_module(wgpu::ShaderModuleDescriptor {
+            label: Some("pellets_render"),
+            source: wgpu::ShaderSource::Wgsl(super::shaders::PARTICLE_RENDER_SHADER.into()),
+        }));
 
         let render_bind_group_layout =
             device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
@@ -436,17 +427,15 @@ impl PelletsModel {
             .build();
 
         // Create compute shaders using GPU utilities
-        let physics_shader = shader_manager.load_shader(
-            device,
-            "pellets_physics_compute",
-            super::shaders::PHYSICS_COMPUTE_SHADER,
-        );
+        let physics_shader = Arc::new(device.create_shader_module(wgpu::ShaderModuleDescriptor {
+            label: Some("pellets_physics_compute"),
+            source: wgpu::ShaderSource::Wgsl(super::shaders::PHYSICS_COMPUTE_SHADER.into()),
+        }));
 
-        let density_shader = shader_manager.load_shader(
-            device,
-            "pellets_density_compute",
-            super::shaders::DENSITY_COMPUTE_SHADER,
-        );
+        let density_shader = Arc::new(device.create_shader_module(wgpu::ShaderModuleDescriptor {
+            label: Some("pellets_density_compute"),
+            source: wgpu::ShaderSource::Wgsl(super::shaders::DENSITY_COMPUTE_SHADER.into()),
+        }));
 
         // Create compute bind group layouts
         let physics_bind_group_layout =
@@ -1355,8 +1344,6 @@ impl PelletsModel {
             AverageColorResources::new(device, &post_effect_texture, &post_effect_view, "Pellets");
 
         Ok(PelletsModel {
-            shader_manager,
-            common_layouts,
             particle_buffer,
             physics_params_buffer,
             density_params_buffer,
diff --git a/src-tauri/src/simulations/shared/gpu_utils.rs b/src-tauri/src/simulations/shared/gpu_utils.rs
index 143edc9..81f595a 100644
--- a/src-tauri/src/simulations/shared/gpu_utils.rs
+++ b/src-tauri/src/simulations/shared/gpu_utils.rs
@@ -2,10 +2,10 @@ use std::collections::HashMap;
 use std::sync::Arc;
 use wgpu::{
     BindGroup, BindGroupDescriptor, BindGroupEntry, BindGroupLayout, BindGroupLayoutDescriptor,
-    BindGroupLayoutEntry, BindingType, Buffer, BufferBindingType, ColorTargetState, ComputePipeline,
-    ComputePipelineDescriptor, Device, FragmentState, PipelineLayoutDescriptor, PrimitiveState,
-    RenderPipeline, RenderPipelineDescriptor, Sampler, ShaderModule, ShaderModuleDescriptor,
-    ShaderSource, ShaderStages, TextureFormat, TextureView, VertexState,
+    BindGroupLayoutEntry, BindingType, Buffer, BufferBindingType, ColorTargetState,
+    ComputePipeline, ComputePipelineDescriptor, Device, FragmentState, PipelineLayoutDescriptor,
+    PrimitiveState, RenderPipeline, RenderPipelineDescriptor, ShaderModule, ShaderModuleDescriptor,
+    ShaderSource, ShaderStages, TextureView, VertexState,
 };
 
 /// Manages shader modules with caching to avoid duplicate compilation
@@ -14,6 +14,12 @@ pub struct ShaderManager {
     shaders: HashMap<String, Arc<ShaderModule>>,
 }
 
+impl Default for ShaderManager {
+    fn default() -> Self {
+        Self::new()
+    }
+}
+
 impl ShaderManager {
     pub fn new() -> Self {
         Self {
@@ -22,12 +28,7 @@ impl ShaderManager {
     }
 
     /// Load a shader module, reusing cached version if available
-    pub fn load_shader(
-        &mut self,
-        device: &Device,
-        name: &str,
-        source: &str,
-    ) -> Arc<ShaderModule> {
+    pub fn load_shader(&mut self, device: &Device, name: &str, source: &str) -> Arc<ShaderModule> {
         self.shaders
             .entry(name.to_string())
             .or_insert_with(|| {
@@ -83,7 +84,10 @@ impl RenderPipelineBuilder {
         self
     }
 
-    pub fn with_vertex_buffer_layouts(mut self, layouts: Vec<wgpu::VertexBufferLayout<'static>>) -> Self {
+    pub fn with_vertex_buffer_layouts(
+        mut self,
+        layouts: Vec<wgpu::VertexBufferLayout<'static>>,
+    ) -> Self {
         self.vertex_buffer_layouts = layouts;
         self
     }
@@ -93,16 +97,6 @@ impl RenderPipelineBuilder {
         self
     }
 
-    pub fn with_depth_stencil(mut self, depth_stencil: Option<wgpu::DepthStencilState>) -> Self {
-        self.depth_stencil = depth_stencil;
-        self
-    }
-
-    pub fn with_multisample(mut self, multisample: wgpu::MultisampleState) -> Self {
-        self.multisample = multisample;
-        self
-    }
-
     pub fn with_fragment_targets(mut self, targets: Vec<Option<ColorTargetState>>) -> Self {
         self.fragment_targets = targets;
         self
@@ -114,39 +108,42 @@ impl RenderPipelineBuilder {
     }
 
     pub fn build(self) -> RenderPipeline {
-        let layout = self.device.create_pipeline_layout(&PipelineLayoutDescriptor {
-            label: self.label.as_deref(),
-            bind_group_layouts: &self.bind_group_layouts.iter().collect::<Vec<_>>(),
-            push_constant_ranges: &[],
-        });
+        let layout = self
+            .device
+            .create_pipeline_layout(&PipelineLayoutDescriptor {
+                label: self.label.as_deref(),
+                bind_group_layouts: &self.bind_group_layouts.iter().collect::<Vec<_>>(),
+                push_constant_ranges: &[],
+            });
 
         let shader = self.shader.expect("Shader not set");
 
-        self.device.create_render_pipeline(&RenderPipelineDescriptor {
-            label: self.label.as_deref(),
-            layout: Some(&layout),
-            vertex: VertexState {
-                module: &shader,
-                entry_point: Some("vs_main"),
-                buffers: &self.vertex_buffer_layouts,
-                compilation_options: Default::default(),
-            },
-            fragment: if self.fragment_targets.is_empty() {
-                None
-            } else {
-                Some(FragmentState {
+        self.device
+            .create_render_pipeline(&RenderPipelineDescriptor {
+                label: self.label.as_deref(),
+                layout: Some(&layout),
+                vertex: VertexState {
                     module: &shader,
-                    entry_point: Some("fs_main"),
-                    targets: &self.fragment_targets,
+                    entry_point: Some("vs_main"),
+                    buffers: &self.vertex_buffer_layouts,
                     compilation_options: Default::default(),
-                })
-            },
-            primitive: self.primitive,
-            depth_stencil: self.depth_stencil,
-            multisample: self.multisample,
-            multiview: None,
-            cache: None,
-        })
+                },
+                fragment: if self.fragment_targets.is_empty() {
+                    None
+                } else {
+                    Some(FragmentState {
+                        module: &shader,
+                        entry_point: Some("fs_main"),
+                        targets: &self.fragment_targets,
+                        compilation_options: Default::default(),
+                    })
+                },
+                primitive: self.primitive,
+                depth_stencil: self.depth_stencil,
+                multisample: self.multisample,
+                multiview: None,
+                cache: None,
+            })
     }
 }
 
@@ -184,22 +181,25 @@ impl ComputePipelineBuilder {
     }
 
     pub fn build(self) -> ComputePipeline {
-        let layout = self.device.create_pipeline_layout(&PipelineLayoutDescriptor {
-            label: self.label.as_deref(),
-            bind_group_layouts: &self.bind_group_layouts.iter().collect::<Vec<_>>(),
-            push_constant_ranges: &[],
-        });
+        let layout = self
+            .device
+            .create_pipeline_layout(&PipelineLayoutDescriptor {
+                label: self.label.as_deref(),
+                bind_group_layouts: &self.bind_group_layouts.iter().collect::<Vec<_>>(),
+                push_constant_ranges: &[],
+            });
 
         let shader = self.shader.expect("Shader not set");
 
-        self.device.create_compute_pipeline(&ComputePipelineDescriptor {
-            label: self.label.as_deref(),
-            layout: Some(&layout),
-            module: &shader,
-            entry_point: Some("main"),
-            compilation_options: Default::default(),
-            cache: None,
-        })
+        self.device
+            .create_compute_pipeline(&ComputePipelineDescriptor {
+                label: self.label.as_deref(),
+                layout: Some(&layout),
+                module: &shader,
+                entry_point: Some("main"),
+                compilation_options: Default::default(),
+                cache: None,
+            })
     }
 }
 
@@ -241,14 +241,6 @@ impl<'a> BindGroupBuilder<'a> {
         self
     }
 
-    pub fn add_sampler(mut self, binding: u32, sampler: &'a Sampler) -> Self {
-        self.entries.push(BindGroupEntry {
-            binding,
-            resource: wgpu::BindingResource::Sampler(sampler),
-        });
-        self
-    }
-
     pub fn with_label(mut self, label: String) -> Self {
         self.label = Some(label);
         self
@@ -354,80 +346,3 @@ impl CommonBindGroupLayouts {
         })
     }
 }
-
-/// Common pipeline templates
-pub struct PipelineTemplates;
-
-impl PipelineTemplates {
-    /// Create a basic render pipeline for full-screen quads
-    pub fn basic_render_pipeline(
-        device: Arc<Device>,
-        shader: Arc<ShaderModule>,
-        bind_group_layouts: Vec<BindGroupLayout>,
-        format: TextureFormat,
-        label: &str,
-    ) -> RenderPipeline {
-        RenderPipelineBuilder::new(device)
-            .with_shader(shader)
-            .with_bind_group_layouts(bind_group_layouts)
-            .with_fragment_targets(vec![Some(ColorTargetState {
-                format,
-                blend: Some(wgpu::BlendState::REPLACE),
-                write_mask: wgpu::ColorWrites::ALL,
-            })])
-            .with_primitive(PrimitiveState {
-                topology: wgpu::PrimitiveTopology::TriangleList,
-                strip_index_format: None,
-                front_face: wgpu::FrontFace::Ccw,
-                cull_mode: Some(wgpu::Face::Back),
-                polygon_mode: wgpu::PolygonMode::Fill,
-                unclipped_depth: false,
-                conservative: false,
-            })
-            .with_label(label.to_string())
-            .build()
-    }
-
-    /// Create a compute pipeline
-    pub fn compute_pipeline(
-        device: Arc<Device>,
-        shader: Arc<ShaderModule>,
-        bind_group_layouts: Vec<BindGroupLayout>,
-        label: &str,
-    ) -> ComputePipeline {
-        ComputePipelineBuilder::new(device)
-            .with_shader(shader)
-            .with_bind_group_layouts(bind_group_layouts)
-            .with_label(label.to_string())
-            .build()
-    }
-
-    /// Create a post-processing pipeline with alpha blending
-    pub fn post_processing_pipeline(
-        device: Arc<Device>,
-        shader: Arc<ShaderModule>,
-        bind_group_layouts: Vec<BindGroupLayout>,
-        format: TextureFormat,
-        label: &str,
-    ) -> RenderPipeline {
-        RenderPipelineBuilder::new(device)
-            .with_shader(shader)
-            .with_bind_group_layouts(bind_group_layouts)
-            .with_fragment_targets(vec![Some(ColorTargetState {
-                format,
-                blend: Some(wgpu::BlendState::ALPHA_BLENDING),
-                write_mask: wgpu::ColorWrites::ALL,
-            })])
-            .with_primitive(PrimitiveState {
-                topology: wgpu::PrimitiveTopology::TriangleList,
-                strip_index_format: None,
-                front_face: wgpu::FrontFace::Ccw,
-                cull_mode: None,
-                polygon_mode: wgpu::PolygonMode::Fill,
-                unclipped_depth: false,
-                conservative: false,
-            })
-            .with_label(label.to_string())
-            .build()
-    }
-} 
\ No newline at end of file
diff --git a/src-tauri/src/simulations/shared/mod.rs b/src-tauri/src/simulations/shared/mod.rs
index bbaab0a..5d7dd70 100644
--- a/src-tauri/src/simulations/shared/mod.rs
+++ b/src-tauri/src/simulations/shared/mod.rs
@@ -28,7 +28,8 @@ pub mod post_processing;
 
 pub use average_color::AverageColorResources;
 pub use gpu_utils::{
-    BindGroupBuilder, CommonBindGroupLayouts, ComputePipelineBuilder, RenderPipelineBuilder, ShaderManager,
+    BindGroupBuilder, CommonBindGroupLayouts, ComputePipelineBuilder, RenderPipelineBuilder,
+    ShaderManager,
 };
 pub use lut::{LutData, LutManager, SimulationLutManager};
 pub use position_generators::{PositionGenerator, SlimeMoldPositionGenerator};
diff --git a/src-tauri/src/simulations/slime_mold/settings.rs b/src-tauri/src/simulations/slime_mold/settings.rs
index 7bb85f9..d80531c 100644
--- a/src-tauri/src/simulations/slime_mold/settings.rs
+++ b/src-tauri/src/simulations/slime_mold/settings.rs
@@ -1,6 +1,6 @@
 use serde::{Deserialize, Serialize};
-use std::ops::Range;
 use std::fmt::Display;
+use std::ops::Range;
 
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct Settings {
@@ -84,10 +84,6 @@ pub struct Settings {
     ///
     /// Defaults to 0.
     pub random_seed: u32,
-    /// Trail map filtering mode.
-    ///
-    /// Defaults to TrailMapFiltering::Nearest.
-    pub trail_map_filtering: TrailMapFiltering,
 }
 
 #[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
@@ -199,7 +195,6 @@ impl Default for Settings {
             diffusion_frequency: 1,
             decay_frequency: 1,
             random_seed: 0,
-            trail_map_filtering: TrailMapFiltering::Nearest,
         }
     }
 }
diff --git a/src-tauri/src/simulations/slime_mold/simulation.rs b/src-tauri/src/simulations/slime_mold/simulation.rs
index db1cac5..f35973e 100644
--- a/src-tauri/src/simulations/slime_mold/simulation.rs
+++ b/src-tauri/src/simulations/slime_mold/simulation.rs
@@ -131,6 +131,7 @@ pub struct SlimeMoldModel {
     pub lut_reversed: bool,
     pub current_lut_name: String,
     pub position_generator: crate::simulations::shared::SlimeMoldPositionGenerator,
+    pub trail_map_filtering: super::settings::TrailMapFiltering,
 
     // Buffer size tracking for pool management
     pub current_trail_map_size: u64,
@@ -316,14 +317,8 @@ impl SlimeMoldModel {
             address_mode_u: wgpu::AddressMode::ClampToEdge,
             address_mode_v: wgpu::AddressMode::ClampToEdge,
             address_mode_w: wgpu::AddressMode::ClampToEdge,
-            mag_filter: match settings.trail_map_filtering {
-                super::settings::TrailMapFiltering::Nearest => wgpu::FilterMode::Nearest,
-                super::settings::TrailMapFiltering::Linear => wgpu::FilterMode::Linear,
-            },
-            min_filter: match settings.trail_map_filtering {
-                super::settings::TrailMapFiltering::Nearest => wgpu::FilterMode::Nearest,
-                super::settings::TrailMapFiltering::Linear => wgpu::FilterMode::Linear,
-            },
+            mag_filter: wgpu::FilterMode::Nearest, // Default to nearest, will be updated later
+            min_filter: wgpu::FilterMode::Nearest, // Default to nearest, will be updated later
             mipmap_filter: wgpu::FilterMode::Nearest,
             ..Default::default()
         });
@@ -500,6 +495,7 @@ impl SlimeMoldModel {
             cursor_size: 300.0,   // Default cursor size
             cursor_strength: 5.0, // Default cursor strength
             position_generator: crate::simulations::shared::SlimeMoldPositionGenerator::Random,
+            trail_map_filtering: super::settings::TrailMapFiltering::Nearest,
             background_params_buffer,
             background_bind_group,
             background_color_buffer,
@@ -1238,7 +1234,7 @@ impl SlimeMoldModel {
             }
             "trailMapFiltering" => {
                 if let Some(filtering_str) = value.as_str() {
-                    self.settings.trail_map_filtering = match filtering_str {
+                    self.trail_map_filtering = match filtering_str {
                         "Nearest" => super::settings::TrailMapFiltering::Nearest,
                         "Linear" => super::settings::TrailMapFiltering::Linear,
                         _ => super::settings::TrailMapFiltering::Nearest,
@@ -1571,6 +1567,7 @@ impl crate::simulations::traits::Simulation for SlimeMoldModel {
             "cursor_size": self.cursor_size,
             "cursor_strength": self.cursor_strength,
             "position_generator": self.position_generator,
+            "trail_map_filtering": self.trail_map_filtering,
             "camera": {
                 "position": self.camera.position,
                 "zoom": self.camera.zoom
@@ -2060,11 +2057,11 @@ impl SlimeMoldModel {
             address_mode_u: wgpu::AddressMode::ClampToEdge,
             address_mode_v: wgpu::AddressMode::ClampToEdge,
             address_mode_w: wgpu::AddressMode::ClampToEdge,
-            mag_filter: match self.settings.trail_map_filtering {
+            mag_filter: match self.trail_map_filtering {
                 super::settings::TrailMapFiltering::Nearest => wgpu::FilterMode::Nearest,
                 super::settings::TrailMapFiltering::Linear => wgpu::FilterMode::Linear,
             },
-            min_filter: match self.settings.trail_map_filtering {
+            min_filter: match self.trail_map_filtering {
                 super::settings::TrailMapFiltering::Nearest => wgpu::FilterMode::Nearest,
                 super::settings::TrailMapFiltering::Linear => wgpu::FilterMode::Linear,
             },
diff --git a/src/lib/GradientEditorMode.svelte b/src/lib/GradientEditorMode.svelte
index adfe382..bda3fab 100644
--- a/src/lib/GradientEditorMode.svelte
+++ b/src/lib/GradientEditorMode.svelte
@@ -161,8 +161,6 @@
           <div class="button-group">
             <button type="button" on:click={reverseGradient} class="btn-action">Reverse</button>
             <button type="button" on:click={exportLUT} class="btn-action">Export</button>
-            <button type="button" on:click={debugTestRed} class="btn-action">Test Red</button>
-            <button type="button" on:click={debugSolidRed} class="btn-action">Solid Red</button>
           </div>
         </div>
         <div class="random-group">
@@ -231,7 +229,7 @@
   let randomStopPlacement: 'Even' | 'Random' = 'Random';
   let randomStopCount: number = 3;
   let gradientStops = [
-    { position: 0, color: '#ff0000' },
+    { position: 0, color: '#0000ff' },
     { position: 1, color: '#ffff00' },
   ];
   let selectedStopIndex = 0;
@@ -413,10 +411,6 @@
 
     // Handle edge cases quickly
     if (position <= gradientStops[0].position) {
-      // Debug: Log when we're at the left edge
-      if (position === 0) {
-        console.log('At left edge (position 0), returning:', gradientStops[0].color);
-      }
       return gradientStops[0].color;
     }
     if (position >= gradientStops[gradientStops.length - 1].position) {
@@ -488,22 +482,6 @@
       bArr.push(bClamped);
     }
 
-    // Debug: Log the first few colors to verify they're correct
-    if (rArr.length > 0) {
-      console.log('=== GRADIENT DEBUG ===');
-      console.log('Gradient stops:', gradientStops);
-      console.log('First gradient stop color:', gradientStops[0].color);
-      console.log('First LUT position (t=0):', getColorAtPosition(0));
-      console.log('RGB values at position 0:', { r: rArr[0], g: gArr[0], b: bArr[0] });
-      console.log('Hex reconstruction:', `#${rArr[0].toString(16).padStart(2, '0')}${gArr[0].toString(16).padStart(2, '0')}${bArr[0].toString(16).padStart(2, '0')}`);
-      console.log('Gradient colors at positions 0, 1, 2:', 
-        `#${rArr[0].toString(16).padStart(2, '0')}${gArr[0].toString(16).padStart(2, '0')}${bArr[0].toString(16).padStart(2, '0')}`,
-        `#${rArr[1].toString(16).padStart(2, '0')}${gArr[1].toString(16).padStart(2, '0')}${bArr[1].toString(16).padStart(2, '0')}`,
-        `#${rArr[2].toString(16).padStart(2, '0')}${gArr[2].toString(16).padStart(2, '0')}${bArr[2].toString(16).padStart(2, '0')}`
-      );
-      console.log('=== END DEBUG ===');
-    }
-
     // Create planar format: [r0, r1, ..., r255, g0, g1, ..., g255, b0, b1, ..., b255]
     const result = new Uint8Array(768);
     result.set(rArr, 0);
@@ -604,32 +582,6 @@
     randomizeGradient(selectedRandomScheme);
   }
 
-  function debugTestRed() {
-    // Set to a simple pure red to pure black gradient for testing
-    gradientStops = [
-      { position: 0, color: '#ff0000' }, // Pure red
-      { position: 1, color: '#000000' }, // Pure black
-    ];
-    selectedStopIndex = 0;
-    console.log('=== DEBUG TEST RED ===');
-    console.log('Set gradient to pure red -> black');
-    console.log('Left stop should be pure red (#ff0000)');
-    updateGradient();
-  }
-
-  function debugSolidRed() {
-    // Set to solid red across the entire gradient for testing
-    gradientStops = [
-      { position: 0, color: '#ff0000' }, // Pure red
-      { position: 1, color: '#ff0000' }, // Pure red
-    ];
-    selectedStopIndex = 0;
-    console.log('=== DEBUG SOLID RED ===');
-    console.log('Set gradient to solid red (#ff0000)');
-    console.log('Entire gradient should be pure red');
-    updateGradient();
-  }
-
   function generateRandomColors(scheme: string): string[] {
     let colors: string[] = [];
 
diff --git a/src/lib/components/shared/CameraControls.svelte b/src/lib/components/shared/CameraControls.svelte
index fc0a1b9..cbd9de0 100644
--- a/src/lib/components/shared/CameraControls.svelte
+++ b/src/lib/components/shared/CameraControls.svelte
@@ -13,16 +13,6 @@
   export let simulationType: string = '';
   export let controlMode: 'camera' | 'simulation' = 'camera';
 
-  // Debug logging for control mode changes
-  $: {
-    console.log(
-      'CameraControls: controlMode changed to:',
-      controlMode,
-      'simulationType:',
-      simulationType
-    );
-  }
-
   const pressedKeys = new Set<string>();
   let animationFrameId: number | null = null;
 
